- [JavaScript](#tab1)
- [TypeScript](#tab2)
- [React](#tab3)
- [Redux](#tab4)
- [NextJS](#tab5)
- [NestJS](#tab6)
- [Node.js и базы данные](#tab7)
- [Прочее](#tab8)

-----------------------------------------------------------------------------------
<a name="tab1"></a>
# JAVASCRIPT
`null и undefined?` -

##
`map reduce filter` -

область видимости (Scope)?

Какие значения в JS являются ложными?

«use strict»?

Какое значение имеет this?

прототип объекта?

ключевое слово «new»?

##
`Модули` - это механизм, который позволяет разделять код на отдельные файлы, каждый из которых может экспортировать свои функции, классы или объекты, и импортировать их в другие файлы, где эти функции, классы или объекты могут быть использованы.

До появления модулей в JS существовало две популярные системы модулей для поддержки кода:
- CommonJS — Nodejs
- AMD (AsyncronousModuleDefinition) — Browsers

```
// ES5 CommonJS - helpers.js
exports.isNull = function(val){
    return val === null
}

// ES5 CommonJS - index.js
const helpers = require('./helpers.js')
const isNull = helpers.isNull
const isUndefined = helpers.isUndefined
const isNullOrUndefined = helpers.isNullOrUndefined

// либо с помощью деструктуризации
const { isNull, isUndefined, isNullOrUndefined } = require('./helpers.js')
```

```
class Helpers {
  // code
}
module.exports = Helpers

// ES5 CommonJS - index.js
const Helpers = require('./helpers.js')
```

чем разница между spread-оператором и rest-оператором?

##
`IIFE` - (Immediately Invoked Function Expression) - это функция, которая вызывается сразу же после ее определения.

IIFE создается путем определения анонимной функции и немедленного вызова ее, обернув ее в скобки. Например:

```
(function () {
  // код
})();
```

IIFE часто используется для создания модульной структуры в JavaScript, позволяющей скрыть реализацию и предоставить только необходимый интерфейс для работы с модулем. Также IIFE используется для создания временных переменных и функций, которые не должны оставаться в памяти после выполнения операций.

##
`AJAX` -

##
`NaN` - это специальное значение в JavaScript, которое означает "Not a Number" (не число). Это значение возвращается, когда выполнение математической операции не может быть завершено корректно или когда результат не является числом.

```
const result = 10 / "hello";
console.log(result); // NaN
```

***Как проверить, является ли значение NaN?***

##
`Унарный плюс (оператор "+")` - в JavaScript используется для преобразования значения в число. Если переданный аргумент не является числом, оператор попытается преобразовать его в число и вернет результат этого преобразования.

```
const str = "42";
const num = +str; // num = 42
```

Если переданный аргумент не может быть преобразован в число, оператор вернет значение NaN (Not a Number)

```
const str = "Hello";
const num = +str; // num = NaN
```

***Является ли использование унарного плюса (оператор "+") самым быстрым способом преобразования строки в число?***

Согласно MDN оператор "+" действительно является самым быстрым способом преобразования строки в число, поскольку он не выполняет никаких операций со значением, которое является числом.

##
`event.preventDefault()` - это метод объекта event в JavaScript, который используется для отмены стандартного действия, которое происходит при выполнении события.

Например, при клике на ссылку можно использовать event.preventDefault() для отмены перехода на новую страницу и выполнения собственной логики обработки клика.

##
`Почему результатом сравнения двух похожих объектов является false?`
 
##
`Как записать несколько выражений в одну строку?`
 
##
`оператор "!!"` - 

##
`Стрелочная функция` -

##
`hoisting js` -

##
`function expression` -

##
`function decralation` -

##
`анонимная функция` -

##
`замыкания` -

##
`arguments` -

##
`ECMAScript` - (ES) - это стандарт, который определяет язык программирования JavaScript. JavaScript был создан в 1995 году Бренданом Айком (Brendan Eich) в компании Netscape. С тех пор язык постоянно развивался, и в 1997 году был стандартизирован организацией Ecma International под названием ECMAScript.

Существует несколько версий стандарта ECMAScript, начиная с ES1 и заканчивая ES11 (известной также как ES2020). Каждая новая версия стандарта вводит новые функциональные возможности и улучшения языка.

Некоторые из ключевых возможностей, которые были введены в различных версиях стандарта ECMAScript:
- ES6 (ES2015): шаблонные строки, стрелочные функции, классы, блочная область видимости переменных (let и const), деструктуризация, параметры по умолчанию, оператор разворота (...), итераторы и генераторы;
- ES7 (ES2016): оператор возведения в степень (**), массивы с индексом;
- ES8 (ES2017): async/await, оператор Object.entries() и Object.values(), функция padStart() и padEnd();
- ES9 (ES2018): оператор spread в объектах, функция Object.getOwnPropertyDescriptors(), функция Promise.finally();
- ES10 (ES2019): функция Array.flat() и Array.flatMap(), функция Object.fromEntries(), оператор optional chaining и nullish coalescing operator.
- ES2020: Оператор опциональной последовательности (?.), новый тип BigInt, новый метод для объекта Promise Promise.allSettled

Реализация новых возможностей стандарта ECMAScript зависит от браузера и среды выполнения JavaScript, поэтому не все браузеры и среды могут поддерживать последние версии стандарта. Для решения этой проблемы используются транспиляторы, которые позволяют использовать современный синтаксис в более старых версиях JavaScript.

##
`DOM` - (Document Object Model) - это стандартный способ представления и взаимодействия с HTML- и XML-документами в браузере. DOM представляет документ в виде дерева объектов, где каждый узел представляет часть документа, такую как элемент HTML, атрибут элемента, текстовый контент и т.д.

Допустим, у нас есть такой HTML:

```
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document Object Model</title>
</head>

<body>
    <div>
        <p>
            <span></span>
        </p>
        <label></label>
        <input>
    </div>
</body>

</html>
```

DOM этого HTML выглядит так:
<img src="https://habrastorage.org/r/w1560/webt/ax/cg/id/axcgidsa8fghreeuyvbhfpga6yo.png"/>

##
`Callback` - («обратный вызов») - это функция, которая передается как аргумент в другую функцию и вызывается внутри этой функции в определенный момент. Этот механизм позволяет обеспечить асинхронное выполнение кода в JavaScript и реализовать несколько операций, выполняющихся параллельно.

В методах map() и filter() функция обратного вызова не вызывается сразу, она вызывается автоматически внутри метода для каждого элемента массива.

##
`async` -

##
`Promise` - это объект в JavaScript, который представляет собой результат асинхронной операции и позволяет выполнять операции с этим результатом. Он используется для работы с асинхронными функциями и позволяет управлять потоком выполнения и обработкой ошибок.

Promise имеет три состояния:
- pending - начальное состояние, когда операция еще не завершена;
- fulfilled - когда операция завершена успешно и возвращает результат;
- rejected - когда операция завершается с ошибкой и возвращает ошибку.

Promise обладает двумя методами для обработки результатов выполнения асинхронной операции:
- then() - вызывается, когда операция завершена успешно;
- catch() - вызывается, когда операция завершается с ошибкой.

Метод then() принимает один или два аргумента - функции обратного вызова (callback). Первый аргумент вызывается, когда операция завершена успешно и возвращает результат. Второй аргумент вызывается, когда операция завершается с ошибкой.

Метод catch() принимает один аргумент - функцию обратного вызова, которая вызывается только в случае ошибки.

Например, пример использования Promise для выполнения запроса к серверу:

```
const promise = new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.open('GET', 'https://example.com/data');
    xhr.onload = () => {
      if (xhr.status === 200) {
        resolve(xhr.response);
      } else {
        reject(new Error(xhr.statusText));
      }
    };
    xhr.onerror = () => {
      reject(new Error('Network error'));
    };
    xhr.send();
  });
  
  promise.then((data) => {
    console.log(data);
  }).catch((error) => {
    console.error(error);
  });
```

##
`prototype` -

##
`Spread` -  это оператор расширения (spread operator) в JavaScript, который позволяет разбирать массивы и объекты на отдельные элементы и добавлять их к другим массивам или объектам. 

C помощью spread оператора можно объединять несколько массивов в один новый массив:

```
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];

const newArr = [...arr1, ...arr2];
```

Оператор расширения также может использоваться для создания копий массивов и объектов, изменения их свойств и добавления новых элементов:

```
const obj = { x: 1, y: 2 };
const newObj = { ...obj, z: 3 };
```

##
`Деструктуризация` - (destructuring) - это способ извлечения значений из массивов и объектов и присвоения их переменным. Она позволяет более удобно и компактно работать с данными в JavaScript.

```
const arr = [1, 2, 3];
const [a, b, c] = arr;
```

```
const obj = { x: 1, y: 2, z: 3 };
const { x, y, z } = obj;
```

##
`Мемоизация` - это прием создания функции, способной запоминать ранее вычисленные результаты или значения. Преимущество мемоизации заключается в том, что мы избегаем повторного выполнения функции с одинаковыми аргументами. Недостатком является то, что мы вынуждены выделять дополнительную память для сохранения результатов.

###
`ооп` -


-----------------------------------------------------------------------------------
<a name="tab2"></a>
# TYPESCRIPT

`TypeScript` - это язык программирования, разработанный и поддерживаемый компанией Microsoft. TypeScript расширяет JavaScript, добавляя статическую типизацию, классы, интерфейсы и другие объектно-ориентированные конструкции к синтаксису JavaScript, что позволяет улучшить разработку крупных приложений и уменьшить количество ошибок. TypeScript компилируется в обычный JavaScript и может быть запущен в любом браузере или на любой платформе, поддерживающей JavaScript.

##
`interface и type` - это две основные конструкции TypeScript для определения пользовательских типов.

##
`enum` - (перечисление) это тип данных, который позволяет определить набор именованных констант с целочисленными значениями.

```
enum Color {
  Red = 0,
  Green = 1,
  Blue = 2
}
```

```
console.log(Color.Red); // выводит 0
```
Вот несколько преимуществ enum:
- Явное указание типа данных: при использовании enum можно явно указать тип данных. В отличие от объектов, где значения могут быть любого типа, значения в enum имеют фиксированный тип.
- Лучшая читабельность: использование enum может повысить читабельность кода, особенно если значения в enum имеют осмысленные имена.


-----------------------------------------------------------------------------------
<a name="tab3"></a>
# REACT
##
`React` - это JavaScript-библиотека для разработки пользовательских интерфейсов (UI), которая была разработана Facebook. React позволяет разрабатывать приложения с использованием компонентной модели, где каждый компонент представляет собой часть интерфейса, которую можно повторно использовать в разных частях приложения.

Основная концепция React - это создание компонентов, которые описывают, как должны выглядеть элементы пользовательского интерфейса в зависимости от различных состояний приложения. Каждый компонент имеет свое состояние и методы жизненного цикла, которые позволяют управлять его поведением.

React также использует виртуальную DOM (virtual DOM), которая позволяет эффективно обновлять только те части пользовательского интерфейса, которые изменились в результате изменений состояния приложения. Это делает React очень быстрым и эффективным для создания масштабируемых приложений.

##
`Виртуальный DOM` - (Virtual DOM) - это техника оптимизации, которая используется в React и других библиотеках для работы с пользовательским интерфейсом. Он представляет собой абстрактное представление пользовательского интерфейса в виде дерева элементов, которое хранится в памяти. Это представление можно быстро обновлять и сравнивать с реальным DOM, что позволяет эффективно обновлять только те элементы, которые изменились, вместо перестройки всего дерева.

В React виртуальный DOM используется следующим образом:
- Когда состояние компонента изменяется, React создает новое дерево элементов пользовательского интерфейса в виде виртуального DOM.
- Затем React сравнивает новое дерево элементов с предыдущим, сохраненным в памяти, и находит различия между ними.
- React обновляет только те элементы, которые изменились, и перестраивает их в реальном DOM.
- Когда обновление завершено, React сохраняет новое дерево элементов в памяти в качестве текущего состояния.

Использование виртуального DOM позволяет существенно ускорить работу с пользовательским интерфейсом в React, поскольку перестройка всего дерева элементов является достаточно затратной операцией. Вместо этого React обновляет только те элементы, которые изменились, и это ускоряет работу приложения и повышает его производительность.

##
`Жизненный цикл` - (lifecycle) в React - это последовательность событий, которые происходят в компоненте с момента его создания и до удаления из DOM. Каждый компонент в React имеет свой жизненный цикл, который можно разделить на три основные фазы: монтирование (mounting), обновление (updating) и размонтирование (unmounting).

1. Mounting (монтирование) - этот этап происходит при создании компонента и включает в себя следующие методы:
- constructor() - вызывается при создании компонента и используется для инициализации состояния и привязки методов к this.
- static getDerivedStateFromProps(props, state) - вызывается после constructor() и перед рендерингом компонента. Он позволяет обновить состояние на основе новых свойств.
- render() - вызывается для отображения компонента в браузере. Он должен возвращать JSX-элементы или null.
- componentDidMount() - вызывается после рендеринга компонента. Этот метод можно использовать, например, для получения данных с сервера.

2. Updating (обновление) - этот этап происходит при изменении свойств или состояния компонента и включает в себя следующие методы:
- static getDerivedStateFromProps(props, state) - вызывается перед рендерингом компонента при изменении свойств. Он позволяет обновить состояние на основе новых свойств.
- shouldComponentUpdate(nextProps, nextState) - вызывается перед рендерингом компонента и позволяет решить, нужно ли обновлять компонент. Этот метод может быть оптимизирован для улучшения производительности.
- render() - вызывается для отображения компонента в браузере.
- getSnapshotBeforeUpdate(prevProps, prevState) - вызывается перед обновлением компонента и позволяет получить состояние компонента до обновления.
- componentDidUpdate(prevProps, prevState, snapshot) - вызывается после обновления компонента. Этот метод можно использовать, например, для выполнения дополнительных действий после изменения состояния.

3. Unmounting (размонтирование) - этот этап происходит при удалении компонента и включает в себя следующий метод:
- componentWillUnmount() - вызывается перед удалением компонента. Этот метод можно использовать, например, для очистки ресурсов, связанных с компонентом.

##
`Классовые и функциональные компоненты` - В React есть два основных подхода для создания компонентов - классовые компоненты и функциональные компоненты.

Классовые компоненты:
- Определяются с помощью ES6-классов;
- Расширяют базовый класс Component;
- Имеют свой собственный состояние (state);
- Имеют доступ к методам жизненного цикла.

Функциональные компоненты:
- Определяются с помощью функций;
- Принимают пропсы в качестве аргументов;
- Не имеют своего собственного состояния (state);
- Не имеют доступа к методам жизненного цикла.

##
`хуки` - это функции, которые позволяют использовать состояние и другие возможности React в функциональных компонентах. Они были введены в React версии 16.8.

Ниже перечислены некоторые из наиболее часто используемых хуков в React:
- useState - позволяет добавлять состояние в функциональный компонент и изменять его при изменении значения.
- useEffect - позволяет выполнять побочные эффекты (например, загрузка данных из API, обновление заголовка страницы и т.д.) в функциональных компонентах в ответ на изменение пропсов, состояния или времени жизни компонента.
- useContext - позволяет использовать контекст для обмена данными между компонентами без передачи пропсов.
- useReducer - позволяет использовать reducer-функцию для обновления состояния компонента.
- useCallback - позволяет создавать мемоизированные версии функций для предотвращения перерендеринга дочерних компонентов.
- useMemo - позволяет мемоизировать результаты вычислений для предотвращения повторного вычисления при каждом рендеринге компонента.
- useRef - позволяет создавать ссылки на элементы DOM или другие значения для использования в функциональных компонентах.
- useLayoutEffect - аналогичен useEffect, но запускается синхронно после изменения состояния компонента, перед рендерингом на экран.
- useCallback - мемоизирует функцию, чтобы предотвратить создание новой функции при каждом рендеринге.
- useImperativeHandle - позволяет настроить значения, которые будут передаваться родительскому компоненту, когда родительский компонент вызывает методы дочернего компонента.

##
`useRef` - это хук (hook) в React, который позволяет получить доступ к DOM-элементу или сохранить значение между рендерами компонента.

Одним из использования useRef может быть сохранение значения между рендерами компонента. Например, вы можете использовать useRef для хранения значения, которое не приводит к перерендеру компонента:

```
import React, { useRef } from 'react';

function MyComponent() {
  const countRef = useRef(0);

  function handleClick() {
    countRef.current++;
    console.log(`Button clicked ${countRef.current} times.`);
  }

  return (
    <div>
      <button onClick={handleClick}>Click me</button>
    </div>
  );
}
```

В этом примере мы создали ссылку на число count с помощью useRef, затем использовали его для подсчета количества нажатий на кнопку без перерендеривания компонента.

##
`useEffect` -

##
`useCallback` -

##
`React.memo и useMemo` -

##
`Props drilling` - (переводится как "передача пропсов") - это практика передачи пропсов из одного компонента в другой компонент через несколько уровней дерева компонентов

##
`контекст` -

##
`другие фрейворки` -

##
`react расширение` -


-----------------------------------------------------------------------------------
<a name="tab4"></a>
# REDUX
`redux` -

##
`redusers` -

##
`actions` -

##
`redux toolkit` -

##
`createsyncthunk` -

##
`extraredusers` -

##
`query redux` -


##
`next and redux`

##
`redux saga` -

##
`mobx` -

##
`middlewhere` -

##
`middlewhere in redux` -

##
`redux расширение` -


-----------------------------------------------------------------------------------
<a name="tab5"></a>
# NEXTJS
`Next.js` - это фреймворк для разработки React-приложений, который предоставляет множество инструментов для создания масштабируемых и быстрых веб-приложений. Он является расширением React и предоставляет множество возможностей для облегчения процесса разработки и оптимизации производительности приложений.

Основные особенности Next.js:
- Рендеринг на стороне сервера: Next.js позволяет выполнять рендеринг на стороне сервера, что повышает скорость загрузки страниц и улучшает оптимизацию поисковых систем.
- Автоматическая оптимизация: Next.js автоматически оптимизирует приложения, включая минификацию и сборку файлов, а также генерацию статических файлов.
- Интуитивный маршрутизатор: Next.js имеет интуитивный маршрутизатор, который позволяет легко управлять маршрутизацией и создавать динамические маршруты.
- Поддержка TypeScript: Next.js поддерживает TypeScript, что позволяет использовать сильную типизацию и повышает надежность приложений.
- Поддержка PWA: Next.js позволяет создавать приложения, которые могут работать в режиме оффлайн и сохраняться на домашний экран мобильных устройств.
- Гибкая настройка: Next.js предоставляет множество настроек и конфигурационных файлов, которые позволяют настраивать приложение под свои нужды.

##
`server side rendering` -

##
`getServerSideProps` - это метод, предоставляемый фреймворком Next.js для получения данных на серверной стороне перед рендерингом страницы.

Когда пользователь запрашивает страницу, Next.js вызывает метод getServerSideProps на сервере, который может получить данные из внешнего источника, например из базы данных, API или файловой системы. Эти данные затем передаются в компонент страницы через объект props.

##
`getinitialsideprops` -

##
`useRouter` - это кастомный hook в библиотеке React, который предоставляет доступ к роутеру в приложении, используя роутинг-библиотеку Next.js. Этот хук используется для получения объекта роутера, который содержит информацию о текущем пути и параметрах запроса, а также позволяет изменять URL и перенаправлять пользователя на другие страницы.


-----------------------------------------------------------------------------------
<a name="tab6"></a>
# NESTJS
`Nest` - это фреймворк для создания масштабируемых серверных приложений на Node.js. Он построен на основе Express.js и использует TypeScript для разработки приложений.

Nest предоставляет множество инструментов и функций для упрощения создания приложений, таких как внедрение зависимостей, контроллеры, провайдеры, сервисы, middleware и т.д.

##
`ORM` - это аббревиатура от Object-Relational Mapping, что означает объектно-реляционное отображение. Это технология, которая связывает объектно-ориентированный код с реляционными базами данных. ORM позволяет использовать объектно-ориентированный подход при работе с данными в базе данных, а не использовать SQL-запросы напрямую. Он представляет данные в виде объектов или классов, а не в виде таблиц и строк базы данных.

##
`orms` -

##
`services` -

##
`modules` -

##
`controllers` -

##
`декораторы` -

##
`провайдеры` -


-----------------------------------------------------------------------------------
<a name="tab7"></a>
# NODEJS И БАЗЫ БАННЫХ
`Типы баз данных` - Существует множество различных типов баз данных, которые отличаются своими характеристиками и применением. Некоторые из наиболее распространенных типов баз данных:
- Реляционные базы данных (RDBMS) - это тип баз данных, который использует таблицы, состоящие из строк и столбцов, чтобы хранить данные. Реляционные базы данных являются наиболее распространенным типом баз данных и используются во многих приложениях.
- NoSQL базы данных - это тип баз данных, который использует неструктурированные данные для хранения информации. NoSQL базы данных часто используются для обработки больших объемов данных, которые не подходят для хранения в реляционных базах данных.
- Иерархические базы данных - это тип баз данных, который использует древовидную структуру для хранения данных. Этот тип баз данных используется чаще всего в приложениях, связанных с геодезией и управлением документами.
- Сетевые базы данных - это тип баз данных, который использует структуру графа для хранения данных. Этот тип баз данных используется чаще всего в научных и исследовательских приложениях.
- Объектно-ориентированные базы данных (OODB) - это тип баз данных, который использует объектную модель данных для хранения информации. OODB базы данных часто используются в приложениях, где объектная модель данных лучше соответствует хранению информации.
- Time-series базы данных - это тип баз данных, который специализируется на хранении и обработке временных рядов данных, таких как данные датчиков IoT, финансовые данные и т. д.
- Графовые базы данных - это тип баз данных, который использует структуру графа для хранения и обработки данных, связанных между собой в виде узлов и ребер.
- In-memory базы данных - это тип баз данных, который хранит данные в оперативной памяти компьютера, что обеспечивает очень высокую скорость доступа к данным.

##
`Реляционные базы данных` - (Relational Databases) - это тип баз данных, где данные хранятся в виде таблиц с определенными связями между ними. Таблицы состоят из строк (записей), каждая из которых имеет уникальный идентификатор (primary key), и столбцов (полей), которые определяют тип данных, хранимых в таблице.

Основные понятия реляционных баз данных:
- Таблицы (Tables) - это основные объекты в реляционных базах данных. Каждая таблица состоит из столбцов и строк, где каждый столбец соответствует определенному типу данных и каждая строка - отдельной записи.
- Связи (Relationships) - это связи между таблицами, которые позволяют объединять данные из нескольких таблиц. Связь между таблицами может быть один-к-одному, один-ко-многим или многие-ко-многим.
- Primary key - это уникальный идентификатор для каждой записи в таблице. Он позволяет быстро идентифицировать и получать доступ к конкретной записи в таблице.
- Foreign key - это ключ, который связывает две таблицы. Foreign key является ссылкой на primary key другой таблицы и позволяет создавать связи между записями в разных таблицах.

##
`postgress` -

##
`MongoDB` -

##
`node` -

##
`express` -


-----------------------------------------------------------------------------------
<a name="tab8"></a>
# ПРОЧЕЕ
`Webpack` - это инструмент сборки модулей для JavaScript-приложений. Он позволяет объединять различные модули JavaScript и другие ресурсы, такие как CSS, изображения, шрифты и т.д., в единый пакет, который можно использовать в браузере.

##
`eslint` - это инструмент статического анализа кода на JavaScript, который помогает выявлять и предотвращать ошибки и несоответствия кодовому стандарту. Он используется в современных проектах на JavaScript для поддержки лучших практик и обеспечения качества кода.

##
`StoryBook` -

##
`GraphQL` -

##
`CI/CD` -
